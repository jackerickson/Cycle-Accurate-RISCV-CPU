`include "memory.v"
`define TB

`define LUI     7'b01101_11      // lui   rd,imm[31:12]
`define AUIPC   7'b00101_11      // auipc rd,imm[31:12]
`define JAL     7'b11011_11      // jal   rd,imm[xxxxx]
`define JALR    7'b11001_11      // jalr  rd,rs1,imm[11:0] 
`define BCC     7'b11000_11      // bcc   rs1,rs2,imm[12:1]
`define LCC     7'b00000_11      // lxx   rd,rs1,imm[11:0]
`define SCC     7'b01000_11      // sxx   rs1,rs2,imm[11:0]
`define MCC     7'b00100_11      // xxxi  rd,rs1,imm[11:0]
`define RCC     7'b01100_11      // xxx   rd,rs1,rs2 
`define FCC     7'b00011_11      // fencex

//FOR CCC, only ident ECALL, not other opcodes
`define CCC     7'b11100_11      // exx, csrxx
//


module fetch_decode(
    input clk,
    output [31:0]instruction,
    output [6:0]opcode,
    output [4:0]rd,
    output [2:0]funct3,
    output [6:0]funct7,
    output [4:0]rs1,
    output [4:0]rs2,
    //shamt is the same thing as rs2, maybe I can just remove shamt and use rs2 in it's place when doing a shift
    output [4:0]shamt,
    output signed [31:0]imm,
    output rs1_e,
    output rs2_e,
    output rd_e,
    output imm_e
   
);
    
    reg [31:0] instruction;
    wire [31:0] mem_out;
    ///Address of the instruction currently in the instruction register
    reg [31:0]PC;
    //Memory access register is 4 bytes ahead so the memory can access it while we process the current instruction
    reg [31:0]next_PC = 32'h01000000;

    //instruction components
    // wire [6:0]opcode;
    // wire [4:0]rd;
    // wire [2:0]funct3;
    // wire [6:0]funct7;
    // wire [4:0]rs1;
    // wire [4:0]rs2;
    // wire [4:0]shamt;

    //immediate should always be sign extended from inst[31]

    //$signed(imm)? or assign extended = {{16{unextend[15]}}, unextend};
    reg signed [31:0]imm;
    reg rs1_e, rs2_e, rd_e, imm_e;

    
    
    memory instruction_mem(.clk(clk),.address(next_PC),.data_in(32'd0),.w_enable(1'b0),.data_out(mem_out));

    // sequential fetching
    always@(posedge clk) begin
        instruction <= mem_out;
        PC <= next_PC;
        //increment the address selector to the memory so the next instruction will be ready to read on the next clk edge
        next_PC <= next_PC + 4;


        // //$write("FD: time=%t, current instruction = %x, next_instruction_ADDR=%x, next_instruction=%x\n", $time, instruction, PC, mem_out);
        //$write("mem stats: time=%t, instruction = %32b, PC=%x\n", $time, instruction, PC-4);

        //$write("instruction components: opcode=%b, rd=%d, func3=%b, func7=%b, rs1=%d, rs2=%d\nimmediate=%d\n\n", opcode, rd, funct3, funct7, rs1, rs2,imm);
        //if(PC >= 32'h01000010) $finish;
        if(instruction == 32'd0) $finish;
    end

    // combinational decoding

    assign opcode = instruction[6:0];
    assign rd = instruction[11:7];
    assign funct3 = instruction[14:12];
    assign rs1 = instruction[19:15];
    assign rs2 = instruction[24:20];
    assign funct7 = instruction[31:25];
    assign shamt = instruction[24:20];

    always@(instruction) begin
        // $write("%x:\t %x = %b %b %b %b \t", PC, instruction, instruction[31:24], instruction[23:16], instruction[15:8], instruction[7:0]);
        $write("%x:\t %x\t", PC, instruction);
        case(opcode)
            `LUI: begin
                //$write("Detected a LUI opcode\n");
                decode_uType();
                $display("LUI    x%0d, 0x%0x", rd, imm);
            end
            `AUIPC: begin
                //$write("Detected a AUIPC opcode\n");
                decode_uType();
                $display("AUIPC  x%0d, 0x%0x", rd, imm);
            end
            `JAL: begin
                //$write("Detected a JAL opcode\n");
                decode_jType();
                $display("JAL    x%0d, %0x", rd, PC+imm);
            end
            `JALR: begin
                //$write("Detected a JALR opcode\n");
                if (funct3 == 3'b000) begin
                    decode_iType();
                    $display("JALR   x%0d, %0d(x%0d)", rd, imm,rs1);
                end
                else $display("Unknown function:%0b of Type JALR");
            end
            `BCC: begin
                //$write("Detected a BCC opcode\n");
                decode_bType();
                case(funct3)
                    3'b000: $display("BEQ    x%0d, x%0d, %0x", rs1, rs2, PC+imm);
                    3'b001: $display("BNE    x%0d, x%0d, %0x", rs1, rs2, PC+imm);
                    3'b100: $display("BLT    x%0d, x%0d, %0x", rs1, rs2, PC+imm);
                    3'b101: $display("BGE    x%0d, x%0d, %0x", rs1, rs2, PC+imm);
                    3'b110: $display("BLTU   x%0d, x%0d, %0x", rs1, rs2, PC+imm);
                    3'b111: $display("BGEU    x%0d, x%0d, %0x", rs1, rs2,PC+imm);
                    default: $display("Unknown BCC Type: %0b", funct3);
                endcase
            end
            `LCC: begin
                //$write("Detected a LCC opcode\n");
                decode_iType();
                case(funct3)
                    3'b000: $display("LB     x%0d, x%0d, %0x", rd, rs1, imm);
                    3'b001: $display("LH     x%0d, x%0d, %0x", rd, rs1, imm);
                    3'b010: $display("LW     x%0d, %0d(x%0d)", rd, imm, rs1);
                    3'b100: $display("LBU    x%0d, x%0d, %0x", rd, rs1, imm);
                    3'b101: $display("LHU    x%0d, x%0d, %0x", rd, rs1, imm);
                    default: $display("Unknown LCC Type: %0b", funct3);
                endcase
            end
            `SCC: begin
                //$write("Detected a SCC opcode\n");
                decode_sType();
                case(funct3)
                    3'b000: $display("SB     x%0d, %0d(x%0d)", rs2, imm, rs1);
                    3'b001: $display("SH     x%0d, %0d(x%0d)", rs2, imm, rs1);
                    3'b010: $display("SW     x%0d, %0d(x%0d)", rs2, imm, rs1);
                    default: $display("Unknown SCC Type: %0b", funct3);
                endcase
            end
            //we will always want to sign extend in MCC opcodes
            `MCC: begin
                //$write("Detected a MCC opcode\n");
                decode_iType();
                case(funct3)
                    //I-Type cases
                    3'b000: $display("ADDI   x%0d, x%0d, %0d", rd, rs1, imm);
                    3'b010: $display("SLTI   x%0d, x%0d, %0d", rd, rs1, imm);
                    3'b011: $display("SLTIU  x%0d, x%0d, %0d", rd, rs1, imm);
                    3'b100: $display("XORI   x%0d, x%0d, %0d", rd, rs1, imm);
                    3'b110: $display("ORI    x%0d, x%0d, %0d", rd, rs1, imm);
                    3'b111: $display("ANDI   x%0d, x%0d, %0d", rd, rs1, imm);
                    //R-Type cases
                    3'b001: $display("SLLI   x%0d, x%0d, 0x%0x", rd, rs1, shamt);
                    3'b101: begin
                        case(funct7)
                            7'b0000000: $display("SRLI     x%0d,, %0d ,%0d)", rd, rs1, shamt);
                            7'b0100000: $display("SRAI     x%0d, %0d ,x%0d)", rd, rs1, shamt);
                            default: $display("Unknown MCC shift variant (%b) under funt3=101", funct7); 
                        endcase
                    end
                    default: $display("Unknown MCC opcode: %b", opcode);
                endcase
                
            end
            `RCC: begin
                //$write("Detected a RCC opcode\n");
                case(funct3)
                    3'b000:begin
                        case(funct7)
                            7'b0000000: $display("ADD    x%0d, %00d ,%0d)", rd, rs1, rs2);
                            7'b0100000: $display("SUB    x%0d, %0d ,x%0d)", rd, rs1, rs2);
                            default: $display("Unknown RCC shift variant (%b) under funt3=000", funct7); 
                        endcase
                    end
                    3'b001: $display("SLL    x%0d, x%0d, x%0d", rd, rs1, rs2);
                    3'b010: $display("SLT    x%0d, x%0d, x%0d", rd, rs1, rs2);
                    3'b011: $display("SLTU   x%0d, x%0d, x%0d", rd, rs1, rs2);
                    3'b100: $display("XOR    x%0d, x%0d, x%0d", rd, rs1, rs2);
                    3'b101:begin
                        case(funct7)
                            7'b0000000: $display("SRL     x%0d,, %0d ,%0d)", rd, rs1, shamt);
                            7'b0100000: $display("SRA     x%0d, %0d ,%0d)", rd, rs1, shamt);
                            default: $display("Unknown RCC shift variant (%b) under funct3=101", funct7); 
                        endcase
                    end
                    3'b110: $display("OR     x%0d, x%0d, x%0d", rd, rs1, rs2);
                    3'b111: $display("AND    x%0d, x%0d, x%0d", rd, rs1, rs2);
                endcase
            end
            `FCC: begin
                //$write("Detected a FCC opcode, these are not implemented\n");

            end
            `CCC: begin
                //$write("Detected a CCC opcode\n");
                if(instruction[31:7] == 25'd0) $display("ECALL  ");


            end


            default: $display("malformed opcode: %0b\n", opcode);


        endcase
        
        

    end

    // Instruction decoder tasks by Type

    // I'm doing sign extension in the decoders, however I think sometimes the immediates are
    // sign extended and sometimes not so maybe need to move sign extension to the case stmnts
    

    //R-type requires no immediate decoding so we can just use assigns, but we must assert the enables
    task decode_rType;
        begin
            rd_e = 1;
            rs1_e = 1;
            rs2_e = 1;
            imm_e = 0;
        end
    endtask

    //12 bit immediate field
    task decode_iType;
        begin
            rd_e = 1;
            rs1_e = 1;
            rs2_e = 0;
            imm_e = 1;
            imm[31:12] = {20{instruction[31]}};
            imm[11:0] = instruction[31:20];
        end
    endtask
    //another 12 bit immediate field but split by the rd1 field
    task decode_sType;
        begin
            rd_e = 0;
            rs1_e = 1;
            rs2_e = 1;
            imm_e = 1;
            imm[31:12] = {20{instruction[31]}};
            imm[11:5] = instruction[31:25];
            imm[4:0] = instruction[11:7];
        end
    endtask

    //13 bit immediate field
    task decode_bType;
        begin
            rd_e = 0;
            rs1_e = 1;
            rs2_e = 1;
            imm_e = 1;
            imm[0] = 1'b0;
            imm[31:13] = {19{instruction[31]}};
            imm[12] = instruction[31];
            imm[11] = instruction[7];
            imm[10:5] = instruction;
            imm[4:1] = instruction[11:8];
        end
    endtask

    task decode_uType;
        begin
            rd_e = 1;
            rs1_e = 0;
            rs2_e = 0;
            imm_e = 1;
            imm[31:12] = instruction[31:12];
            imm[11:0] = 12'd0;
        end
    endtask

    task decode_jType;
        begin
            rd_e = 1;
            rs1_e = 0;
            rs2_e = 0;
            imm_e = 1;
            imm[31:21] = {11{instruction[31]}};
            imm[19:12] = instruction[19:12];
            imm[11] = instruction[20];
            imm[10:1] = instruction[30:21];
            imm[20] = instruction[31];
        end
    endtask


endmodule


module dut;


    reg clk = 0;
    wire [31:0]instruction;
    wire [6:0]opcode;
    wire [4:0]rd;
    wire [2:0]funct3;
    wire [6:0]funct7;
    wire [4:0]rs1;
    wire [4:0]rs2;
    wire [4:0]shamt;
    wire signed [31:0]imm;
    wire rs1_e;
    wire rs2_e;
    wire rd_e;
    wire imm_e;
    wire [31:0] PC;

    initial begin
        $dumpvars(0, fd1);

        //if($time >= 50) #10 $finish;

    end


    // fetch_decode fd1(.clk(clk), .instruction(instruction), .opcode(opcode), .rd(rd), .funct3(funct3), .funct7(funct7), .rs1(rs1),
    //                      .rs2(rs2), .shamt(shamt), .rs1_e(rs1_e), .rs2_e(rs2_e), .rd_e(rd_e) .imm_e(imm_e)
    //                 );

    fetch_decode fd1(clk, instruction, opcode, rd, funct3, funct7, rs1, rs2, shamt, imm, rs1_e, rs2_e, rd_e, imm_e, PC);

    always begin
        #5 clk <= ~clk;
    end



    always@(posedge clk) begin
        // opcode determines instruction format, except for MCC types instructions (SLLI, SRLI, and SRAI are different than the other MCC instructions)
        $write("TB: current instruction components: opcode=%7b, func3=%3b, func7=%7b, rd=x%0d, rs1=x%0d, rs2=x%0d\nimm=%d\n\n", opcode, funct3, funct7, rd, rs1, rs2,imm);
        //$display("TB");
    end

endmodule
